# 从Google V8的角度重识JavaScript -技安（何禹）

## 我们从一道简单的面试题开始

我们从一道简单的面试题开始，首先我们先来看一段可能对大家来说再熟悉不过的代码：

```javascript
function outer() {
  var a = 1
  function inner() {
    console.log(a)
  }
  return inner
}
var b = outer()
b()  // 1
```

我们声明一个变量a，一个函数inner，并且在函数inner中通过打印的方法调用变量a。根据词法作用域的查找原理，在函数inner里显然是能访问到变量a的。然后，我们将声明的变量a和函数inner用一个新的全局函数outer包裹，那么在outer外面显然无法访问到变量a。那么重点来了，如果我们将访问变量的函数inner作为返回值从函数outer中返回，再在全局下声明变量b，并将函数outer执行返回的结果赋值给变量b。此时我们就可以在函数outer之外访问到变量a。此时这个返回的函数inner，我们将其称之为**闭包（Closure）**。用非常高深的词汇来解释一下闭包，其本质是**当函数可以记住并访问其所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域以外执行**。通俗来讲，闭包的含义就是**在函数外可以访问到函数内部的变量**。闭包对于前端开发来说，其实是一个再熟悉不过的特性了。在如今的前端面试中，九成的面试者都可以按照上面的代码回答出“什么是闭包”的问题。

我们在这个问题上拓展一下，面试官会在进行如下提问：
- 闭包的作用是什么？ 
- 闭包有什么影响？ 
根据上面两个问题，候选人会进行如下回答：
- 闭包可以让我们访问函数内声明的变量，并且这些可访问的变量会一直保存在内存中。在没有引入esModule之前，早期社区提出的一些模块解决方案便是基于闭包的原理来实现的。 
- 由于闭包的形成使得函数内的变量始终保持在内存中，使得这部分内存**始终被占用**。过多使用闭包会使得内存使用过大，导致网页的性能下降。**如果是IE中，还会有内存泄漏的问题**。 
  
能回答到这个地步，其实已经算是初步理解闭包的含义了。但我们有没有深入想过一个问题：我们都知道函数在执行完成之后，会销毁掉其中声明的变量，释放内存。而闭包中访问的变量，在其原有的函数执行完成之后，由于在全局作用域中可以访问到，那么这部内存究竟有没有被释放呢？换句话说，以V8为例，JS引擎在实现闭包的时候，是如何处理内存的占用和销毁呢？

## V8是如何实现闭包的

要搞清楚V8是如何实现闭包的，我们需要对于V8对JS的编译执行有一定的了解，这包括了V8在解析JS之前的准备工作（运行时环境）以及对于JS的编译执行流程。当你对V8是如何把玩JS有所了解之后，自然也就理解了V8是如何实现闭包的了。

### 运行时环境

V8的运行时环境在执行JS代码之前其实就已经准备好了，这个环境主要包括了数据存储空间：堆空间和栈空间，全局执行上下文和作用域，内置的内建函数及拓展函数，以及消息循环系统。整体结构如下图所示：
![环境结构](/assets/architecture.jpeg)

准备好运行时环境之后，V8便可以按执行流程处理JS代码。在闭包这个知识点中，我们重点关注V8的数据存储空间——**堆空间(Heap)和栈空间(Stack)**。

### 栈空间

我们在开发中，时常会碰到如下的情况，比如我执行下面这段代码，在控制台会打印出如下错误：

```javascript
function foo() {
  foo()
}
foo()//Uncaught RangeError: Maximum call stack size exceeded
```

从字面意思来看，是说“超出了调用栈的大小”。我们在执行JS的时候，由于在函数foo中调用自己，使得该函数不停地循环调用，因此执行时所需的内存超出了调用栈的大小，浏览器报告了栈溢出的错误。那么函数在被调用的时候，是如何使用调用栈的呢？
熟悉数据结构的同学都知道，栈结构是非常适合去管理函数的调用的。这是因为函数最主要的两个特性：
1. 函数是可以被调用的，特别是在JS中，函数甚至可以在另一个函数内被调用。当函数调用发生时，执行代码的控制权便会从父函数转移到子函数上，当子函数执行结束后，子函数会将代码控制权交回给父函数。 
2. 函数具有作用域机制，使得在执行的时候可以将定义在函数内部的变量与外部环境隔离，在函数内部定义的变量，在函数外部是无法访问的，当函数执行结束后，这些函数内部声明的变量也会随之销毁。 
通过以上两个特性，我们可以描述出函数在循环调用时的执行场景：

```javascript
function b() {
  var c = 1
  console.log(c)
}

function a() {
  b();
  console.log(2)
}
a()
```

1. 当函数a被调用时，执行函数a中的内容，此时代码的执行控制权在函数a中。 
2. 当执行到函数b在函数a内被调用的这行代码时，此时代码的执行控制权由函数a转移到函数b中。 
3. 当函数b执行完毕后，函数b将代码控制权交换到函数a，函数a继续执行。函数b内部声明的变量此时会随着该函数的执行上下文一起销毁，这部分内存会被释放。 
4. 函数a执行完毕后，函数a内部声明的变量会随着该函数的执行上下文一起销毁，这部分内存会被释放。 

通过以上步骤，我们可以得出如下结论：**函数调用者的生命周期永远比被调用者的声明周期长，且被调用者的生命周期总是先于调用者的生命周期结束**。考虑到函数的作用域机制，在函数执行时，内存会为该函数分配函数执行上下文，声明变量等数据。当函数执行结束后，这部分数据会从内存中被销毁。结合函数的生命周期来看，**被调用函数所占用的内存资源分配要晚于调用者的内存资源分配（后进），且被调用函数的内存资源销毁要早于调用者的内存资源销毁（先出）**。这种**后进先出（LIFO）**的策略，与栈结构的后进先出原则高度契合，因此。**栈空间一般用来管理函数的调用关系**，以及储存函数执行时所需的数据。

理解了这一点，我们再看上面那个栈溢出的问题就十分容易理解了：函数foo执行，V8为该函数分配栈空间，用来存储内部变量以及执行上下文。在其内部执行到函数foo的调用时，代码的执行控制权由外层函数foo函数转移到内层函数foo中，并且V8为内层函数foo分配栈空间，用来存储其变量和执行上下文。依次类推，这样不断执行调用下去后，代码的控制权不断地向下转移，V8也不断地为其分配栈空间，最终导致栈溢出。因此浏览器会报告栈溢出的错误。

### 堆空间

栈空间作为管理函数调用的空间结构，有非常多的优势：其后进先出的原则与函数调用过程高度契合；由于栈空间在内存中的表现为一块儿连续的空间的原因，在栈空间内分配资源与销毁资源的速度非常快。
但是由于栈空间在内存中需要占用一大块连续的空间，因此栈空间的大小通常非常有限。这也就是为什么会有栈溢出的问题存在。那我们在内存中如果需要保存很大的数据，通常会用到另一种数据结构——**堆空间**。

与栈空间的连续性不同，堆空间中的数据是不要求连续存放的，我们可以在任何时候分配和销毁它。在日常的开发中势必要保存一些复杂的变量，例如数组，多层嵌套的对象等等。这些变量或层级复杂，或字段繁多。如果保存在栈空间中，虽然保证了查找速度，但是也占据大量连续的空间，因此V8在面对这些变量时，将其保存在堆空间中，**并将其存储地址返回给声明变量所在的调用栈**。当在函数中调用这些变量时，实际上是调用了存储在栈中存储的地址，借由地址访问到存储在堆空间的变量数据。当函数执行完成后，该函数在栈空间中的所有数据被销毁，堆中储存的复杂变量由于访问其地址的代码已经执行完成，变为不可访问状态。便会触发**垃圾回收机制（Garbage collection）**，被垃圾回收器回收，释放内存。

### 延迟解析

理解了栈空间与堆空间，以及函数执行时对于内存布局的影响之后。若要理解V8如何实现闭包，我们还需要对V8对JS代码的操作流程有一定的了解：

首先V8在拿到JS代码之后，经历了**编译**和**执行**两个阶段。**在编译过程中，V8引擎首先将JS代码转换为AST树，与此同时根据代码生成相应作用域。AST树之后转换为字节码，转换后的字节码在执行过程中可以被JS解释器直接执行。而反复执行的代码被监控模块标记为热点代码，热点代码被转化成机器代码后再执行，使得执行效率提升。**

而在编译过程中，其实V8并不会一次性将所有的JS代码全部解析为AST和字节码。其原因在于等待时间过长以及占用内存过多。基于此，**V8采用了延迟解析（Lazy Parsing）的方式，用来解决编译过程中时间和空间的性能问题**。具体规则如下：
1. 解析器在解析JS文件时，遇到函数声明，会跳过函数内部的代码，而是将函数声明作为函数对象，保存在内存中，仅仅生成顶层代码的AST和字节码。 
2. 当顶层代码解析完成后，进入执行阶段，执行到函数调用时，会从函数对象中取出函数内部的代码，进行解析，生成AST和字节码。然后再由解释器进行解释执行。依次类推。 

这样的处理可以使得在顶层代码解析执行后，立刻有结果反馈给用户，使得用户在感官上缩短了编译时间，而当内部的函数进行解析执行时，所占用的内存又会随着函数的生命周期而销毁。因此从时间和空间两个方面解决了V8编译执行JS的性能问题。

### 闭包在V8中的实现

我们仔细理解延迟解析的过程可以发现，这种解析原则与闭包的实现是相悖的。正因为JS的闭包特性，使得V8对于JS的解析执行过程变得更加复杂。
通过观察闭包，我们可以发现，闭包本身有如下特点：
1. 函数内部可以访问函数所在的词法作用域。我们在函数outer内声明一个变量a和另一个函数inner，那么在函数inner里是可以访问到变量a的。 
2. 函数可以作为返回值，当我们把函数内部的函数作为返回值时。这也就意味着我们将内部的函数保存了下来，可以在我们任意需要的地方进行调用。而不管我们在何时调用时，都可以访问到该函数能访问到其声明时所在的词法作用域，哪怕调用的地点在词法作用域之外。 

结合闭包的特点和延迟解析的原则。我们来看一下本文最开始那段闭包代码的执行过程：
1. V8编译顶层代码，生成AST树和字节码，以及全局执行上下文和全局变量。遇到函数outer的声明，在栈空间中分配空间，将函数outer作为函数类型的对象保存在堆空间中，并返回其地址储存在栈空间中全局环境对应的栈帧。 
2. 执行顶层代码，遇到执行函数outer，生成函数outer对应的上下文，以及函数outer对应的词法作用域，从堆空间中取得函数outer内部代码，进行编译解析，将声明的变量a放到栈空间中函数outer对应的栈帧中。遇到函数inner的声明，将其作为函数对象保存在堆空间中，并返回其地址储存在栈空间中函数outer对应的栈帧中。在执行过程中将函数对象inner作为返回值，赋值给全局变量b。 
3. 函数outer执行结束后，函数outer对应的栈帧被销毁。包括outer的执行上下文以及其内部声明的变量，其中当然也包括变量a。 
4. 执行变量b（函数类型），取出函数对象inner内部代码，进行编译解析执行。 

过程梳理到此，我们会发现，由于延迟解析的原则，在函数inner执行的期间，其声明时所在的栈空间部分已经被销毁，因此inner函数中调用的原outer作用域中的变量实际上也随着被销毁了。这与闭包特性的实现是不相符的。因此，为解决这个问题，V8在延迟解析的基础上做了一番改进。在编译过程中，增加了**预解析器（Preparser）**的模块。 在解析代码遇到函数声明时，解析过程会跳过该函数，并将其保存在堆空间中，而预解析器则会对该函数声明进行一次快速的预解析，其目的主要有两个：
- 判断当前函数是否存在语法错误，如果遇到语法错误，直接抛出。 
- 判断当前函数是否引用了函数外部的变量，**预解析器会把函数引用的外部变量复制到堆空间中，在执行到该函数时，直接引用堆中的引用。**

也就是说，在返回的函数真正被执行时，其访问到原词法作用域中的变量已经在预解析阶段被复制到堆空间中。堆空间中的变量地址保存在返回函数的栈空间内，随着返回函数的执行完成而销毁。这样也就实现了闭包的特性，同时也满足了V8延迟解析的原则。

### 题外话：内存泄漏

提到闭包带来的问题，很多面试者在回答时，可能会不假思索地回答出：“造成**内存泄漏（Memory Leak）**。”从JS语言本身分析，这样回答看上去没什么问题。但是我们根据上面V8对于闭包的实现可以分析出，闭包的问题与内存泄漏没有什么关系。因为原本函数outer内部的变量已经在函数outer执行完成之后被释放了。而在函数outer的词法作用域外执行其返回函数inner时，访问的是堆空间中的变量复制品。而该变量则是与函数inner的执行上下文的生命周期保持同步的。在代码中我们将返回的函数inner赋值给了全局变量。因此该复制品会一直被保存在堆空间中。而垃圾回收机制检测到该变量时会认为该变量是可访问到的，因此不会将其回收。垃圾回收机制不会回收一个被认为是有用的变量，所以这也就不是内存泄漏的问题了。

而之所为会有这个“内存泄漏”的说法存在，是因为在IE浏览器中存在一个bug，**IE所使用的JS引擎在我们使用完闭包后，仍然不会对该变量进行回收**。因此这是IE的问题，而不是闭包的问题。具体细节可以参考司徒正美大神所写的一篇[文章](https://www.cnblogs.com/rubylouvre/p/3345294.html)。

## 关于V8
### 我们为什么要学习V8？

至此，我们了解到V8如何通过延迟解析，预解析以及堆栈空间的布局变化来实现闭包。其实这只是V8对于JS特性实现的一个简单例子。JS中的诸多特性，简单如**变量提升（Hoisting）**，**类型转换**；复杂如**Event loop**，**宏任务**和**微任务**等。这些特性在V8当中的实现方式都值得我们去深入一番。这也就是所谓的“从新的角度去审视Javascript”。如果我们可以从V8的角度去了解这些特性的实现机制，在理解这些特性时就有了实验的支撑，对这些特性有了更加直观的理解，使我们免于死记硬背盲目记忆。

虽然在目前的市面上除了V8之外还有很多JS引擎。但随着Google浏览器以及安卓系统的普遍，以及Node.JS的不断发展，V8引擎作为当下最为流行的JS引擎当之无愧。我们在前端开发中，除了要了解JS这门语言的特性，对于浏览器的工作原理也需要深入地了解。这对于我们排查代码中因编写方式造成的内存使用过多，网页卡顿等问题会有很大的帮助；抑或是在开发Node的服务时，如果遇到了任务阻塞的问题，当我们熟悉JS任务队列的原理，这些问题便可迎刃而解。而学习V8的基本运行机制，学习V8编译执行JS的过程，正是让我们可以深入了解这门语言的一条捷径。

### V8 for debug

我们学习V8的时候，会接触到一个非常有用的调试工具——d8（v8 for debug），这个工具不仅可以帮助我们看到V8在执行JS时每个时期的中间产物：AST树，字节码，二进制机器码；还可以根据d8提供的trace-gc命令来查看垃圾回收的状态。甚至可以通过d8工具看到V8是如何标记热点代码并优化编译过程的。通过使用d8工具，我们可以更加清晰地看到V8对于JS中特性的实现以及性能的优化。

正常来说，我们需要通过编译V8来生成d8工具，但是由于V8的很多依赖需要非常良好的外网环境，并且生成工程文件，编译d8的过程也比较繁琐。因此我在实验了多种方法后，推荐一种个人认为最简单便捷，却十分有效的获取途径——**jsvu**。

**jsvu，全称为JS (engine) Version Updater。即JS引擎版本更新工具**，我们能够依靠它来下载和更新不同的JS引擎，不仅仅是V8。还有Chakra，GraalJS，JSCore，SpiderMonkey等等。我们通过安装并使用jsvu，可以将V8以及d8下载到本地环境，然后直接通过命令行使用即可，具体操作如下(默认命令行为zsh)：

1. 首先全局安装jsvu cli 
```zsh
npm install jsvu -g
```
2. 安装完成之后，执行jsvu后，我们可以根据自己的需求选择操作系统和所需安装JS引擎，这里我们选择mac64以及v8-debug和v8，操作系统选择mac。 另外，jsvu命令同时也支持操作系统和JS引擎的参数，我们也可以使用如下命令来进行安装： 
```zsh
jsvu --os=mac64 --engines=v8-debug,v8
```
3. 安装完成后，我们需要将安装目录 $HOME/.jsvu/v8-debug 设置一个alias，我们可以将其添加至~/.zshrc中，这样在我们每新开一个命令行时，都可以直接执行d8的命令，具体操作过程如下：

```zsh
vim ~/.zshrc
// 添加下面到 .zshrc 中
alias d8='~/.jsvu/v8-debug'
source ~/.zshrc
```
安装完成后，在命令行输入d8 --help 进行验证，此时如果我们可以成功弹出d8的相关命令信息，则说明该调试工具以及安装成功了。

![安装结果](/assets/google-result-1.png)

我们来拿一个简单的例子来试验一下：
1. 在命令行中新建一个JS文件，命名为closure.js。将刚才的闭包写到closure.JS文件中。 
   
```zsh
mkdir d8-test && cd d8-test
vim closure.js
```
```javascript
// closure.js
function outer() {
  var a = 1
  function inner() {
    console.log(a)
  }
  return inner
}
var b = outer()
b()
```

5. 文件创建完成后。在命令行输入如下命令，以查看该JS转化为AST树的产物： 
 
```zsh
d8 --print-ast closure.js 
```

弹出结果如下：

![安装结果](/assets/google-result-2.png)

学会使用d8调试JS，可以使我们对于V8对JS的解析执行和特性实现都能有更深的理解。

## 结束语

在前端的学习中，JS的相关特性是前端开发的基础知识，我们理应深入了解，而不仅仅是停留在简单的认知层面。从V8引擎对于特性实现的角度去学习JS，相当于看到了JS特性的另一维度，从实现特性的角度去理解特性，这对我们加深对特性本身的理解很有帮助。希望这篇短文可以激发你对于V8探究的乐趣，从不同的角度认识JS，在前端之路上继续前行。
 